/**
 * TileEditor Data Manager - Handles all data operations
 */
class DataManager {
    constructor(tileEditor) {
        this.tileEditor = tileEditor;
    }

    async saveBiomeCategory(category) {
        try {
            // Get tiles for this category
            const categoryTiles = this.tileEditor.tiles.filter(tile => tile.categoryId === category.id);
            
            // Save biome config data
            const biomeData = {
                name: category.name,
                type: category.type,
                color: category.color,
                description: category.description,
                folderPath: category.folderPath,
                icon: category.icon
            };
            
            // Save biome config to biomeData.js file
            const biomeSuccess = await this.tileEditor.saveBiomeSettings(category.name, biomeData);
            
            // Save tiles as separate JavaScript list in tiles folder
            const tilesSuccess = await this.saveTilesList(category.name, categoryTiles);
            
            if (biomeSuccess && tilesSuccess) {
                // // // // // // // // console.log(`[DataManager] Biome category ${category.name} and tiles saved successfully`);
                return true;
            } else {
                // console.(`[DataManager] Failed to save biome category ${category.name} or tiles`);
                return false;
            }
        } catch (error) {
            // console.(`[DataManager] Error saving biome category ${category.name}:`, error);
            return false;
        }
    }

    async saveTilesList(biomeName, tiles) {
        try {
            const tilesListContent = `// Tiles list for ${biomeName}
// Generated by TileEditor
const ${biomeName.toLowerCase()}TilesList = ${JSON.stringify(tiles, null, 2)};

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ${biomeName.toLowerCase()}TilesList;
}

// Global access
window.${biomeName.toLowerCase()}TilesList = ${biomeName.toLowerCase()}TilesList;`;

            // Send file to server to save in tiles folder
            const response = await fetch('/api/save-tiles-list', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    biomeName: biomeName,
                    fileContent: tilesListContent
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            // // // // // // // // console.log(`[DataManager] Tiles list saved successfully for ${biomeName}:`, result);
            return true;
        } catch (error) {
            // console.(`[DataManager] Failed to save tiles list for ${biomeName}:`, error);
            return false;
        }
    }

    async saveAllBiomeData() {
        // // // // // // // // console.log('[DataManager] Saving all biome data...');
        
        const savePromises = this.tileEditor.categories.map(category => this.saveBiomeCategory(category));
        const results = await Promise.all(savePromises);
        
        const successCount = results.filter(result => result).length;
        // // // // // // // // console.log(`[DataManager] Successfully saved ${successCount}/${this.tileEditor.categories.length} biome categories`);
        
        return successCount === this.tileEditor.categories.length;
    }

    async reloadBiomeData(biomeName) {
        // // // // // // // // console.log(`[DataManager] Reloading biome data for ${biomeName}`);
        
        try {
            // Reload the specific biome data
            const biomeData = await this.tileEditor.loadBiomeData(biomeName);
            if (biomeData && biomeData.tiles) {
                // Find the category
                const category = this.tileEditor.categories.find(c => c.name === biomeName);
                if (category) {
                    // Remove old tiles for this category
                    this.tileEditor.tiles = this.tileEditor.tiles.filter(t => t.categoryId !== category.id);
                    
                    // Add new tiles
                    let newId = Math.max(...this.tileEditor.tiles.map(t => t.id), 0) + 1;
                    biomeData.tiles.forEach(tile => {
                        this.tileEditor.tiles.push({
                            id: newId++,
                            name: tile.name,
                            categoryId: category.id,
                            image: tile.image,
                            movementCost: tile.movementCost || 1,
                            defenseBonus: tile.defenseBonus || 0,
                            resources: tile.resources || '',
                            description: tile.description || `Tile aus ${category.name}`
                        });
                    });
                    
                    // // // // // // // // console.log(`[DataManager] Reloaded ${biomeData.tiles.length} tiles for ${biomeName}`);
                    
                    // Update UI
                    this.tileEditor.uiManager.updateTilesList();
                    this.tileEditor.uiManager.displayCategories(this.tileEditor.categories);
                }
            }
        } catch (error) {
            // console.(`[DataManager] Failed to reload biome data for ${biomeName}:`, error);
        }
    }

    async forceReloadBiomeData(biomeName) {
        // // // // // // // // console.log(`[DataManager] Force reloading biome data for ${biomeName}`);
        
        try {
            // Add cache-busting parameter to force fresh load
            const timestamp = Date.now();
            const response = await fetch(`assets/biomes/${biomeName}/biomeData.js?t=${timestamp}`, {
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            });
            
            if (response.ok) {
                const jsContent = await response.text();
                // Extract the data from the JS file
                const dataMatch = jsContent.match(/window\.BIOME_DATA\s*=\s*({[\s\S]*});/);
                if (dataMatch) {
                    const biomeData = eval('(' + dataMatch[1] + ')');
                    
                    // Find the category
                    const category = this.tileEditor.categories.find(c => c.name === biomeName);
                    if (category) {
                        // Remove old tiles for this category
                        this.tileEditor.tiles = this.tileEditor.tiles.filter(t => t.categoryId !== category.id);
                        
                        // Add new tiles
                        let newId = Math.max(...this.tileEditor.tiles.map(t => t.id), 0) + 1;
                        biomeData.tiles.forEach(tile => {
                            this.tileEditor.tiles.push({
                                id: newId++,
                                name: tile.name,
                                categoryId: category.id,
                                image: tile.image,
                                movementCost: tile.movementCost || 1,
                                defenseBonus: tile.defenseBonus || 0,
                                resources: tile.resources || '',
                                description: tile.description || `Tile aus ${category.name}`
                            });
                        });
                        
                        // // // // // // // // console.log(`[DataManager] Force reloaded ${biomeData.tiles.length} tiles for ${biomeName}`);
                        
                        // Update UI immediately
                        this.tileEditor.uiManager.updateTilesList();
                        this.tileEditor.uiManager.displayCategories(this.tileEditor.categories);
                        
                        // Also update biome modal if it's open
                        if (document.getElementById('biomeModal').classList.contains('show')) {
                            this.tileEditor.modalManager.loadBiomeTiles(category);
                        }
                    }
                }
            }
        } catch (error) {
            // console.(`[DataManager] Failed to force reload biome data for ${biomeName}:`, error);
        }
    }

    saveCategoryOrder() {
        try {
            const orderData = this.tileEditor.categories.map((cat, index) => ({
                id: cat.id,
                name: cat.name,
                order: index
            }));
            localStorage.setItem('tileEditor_categoryOrder', JSON.stringify(orderData));
            // // // // // // // // console.log('[DataManager] Category order saved to localStorage');
        } catch (error) {
            // console.('[DataManager] Failed to save category order:', error);
        }
    }

    loadCategoryOrder() {
        try {
            const savedOrder = localStorage.getItem('tileEditor_categoryOrder');
            if (savedOrder) {
                const orderData = JSON.parse(savedOrder);
                // // // // // // // // console.log('[DataManager] Loaded saved category order:', orderData);
                
                // Reorder categories based on saved order
                const orderedCategories = [];
                orderData.forEach(item => {
                    const category = this.tileEditor.categories.find(cat => cat.id === item.id);
                    if (category) {
                        orderedCategories.push(category);
                    }
                });
                
                // Add any new categories that weren't in the saved order
                this.tileEditor.categories.forEach(category => {
                    if (!orderData.find(item => item.id === category.id)) {
                        orderedCategories.push(category);
                    }
                });
                
                this.tileEditor.categories = orderedCategories;
                return true;
            }
        } catch (error) {
            // console.('[DataManager] Failed to load category order:', error);
        }
        return false;
    }

    resetCategoryOrder() {
        if (confirm('Möchtest du die Kategorie-Reihenfolge wirklich zurücksetzen?')) {
            // // // // // // // // console.log('[DataManager] Resetting category order...');
            
            // Remove saved order from localStorage
            localStorage.removeItem('tileEditor_categoryOrder');
            
            // Reload categories from original source
            this.tileEditor.loadTileAssets().then(() => {
                this.tileEditor.initializeCategories();
                // // // // // // // // console.log('[DataManager] Category order reset successfully');
                this.tileEditor.showToast('Kategorie-Reihenfolge wurde zurückgesetzt!', 'success');
            });
        }
    }

    async refreshBiomeCategories() {
        // // // // // // // // console.log('[DataManager] Refreshing biome categories...');
        
        try {
            // Reload categories from folders
            this.tileEditor.categories = await this.tileEditor.loadCategoriesFromBiomeFolders();
            
            // Reload tiles
            this.tileEditor.tiles = await this.tileEditor.loadTilesFromBiomeFolders();
            
            // Update UI
            this.tileEditor.uiManager.updateCategoriesList();
            this.tileEditor.uiManager.updateCategoryFilter();
            this.tileEditor.uiManager.updateTilesList();
            
            // Update header filter
            this.tileEditor.uiManager.updateHeaderBiomeFilter();
            
            // Benachrichtige HexMap Editor über Änderungen
            if (window.updateHexMapBiomeOptions) {
                window.updateHexMapBiomeOptions();
            }
            
            // // // // // // // // console.log('[DataManager] Biome categories refreshed successfully');
            this.tileEditor.showToast('Biome-Kategorien wurden erfolgreich neu geladen!', 'success');
            
        } catch (error) {
            // console.('[DataManager] Failed to refresh biome categories:', error);
            this.tileEditor.showToast('Fehler beim Neuladen der Biome-Kategorien', 'error');
        }
    }

    exportBiomeData() {
        // // // // // // // // console.log('[DataManager] Exporting biome data');
        
        if (!this.tileEditor.selectedCategoryId) {
            this.tileEditor.showToast('Bitte wähle zuerst eine Kategorie aus', 'warning');
            return;
        }
        
        const category = this.tileEditor.categories.find(c => c.id === this.tileEditor.selectedCategoryId);
        if (!category) return;
        
        // Get tiles for this category
        const categoryTiles = this.tileEditor.tiles.filter(tile => tile.categoryId === category.id);
        
        const biomeData = {
            name: category.name,
            type: category.type,
            color: category.color,
            description: category.description,
            folderPath: category.folderPath,
            icon: category.icon,
            tiles: categoryTiles.map(tile => ({
                name: tile.name,
                image: tile.image,
                movementCost: tile.movementCost,
                defenseBonus: tile.defenseBonus,
                resources: tile.resources,
                description: tile.description
            }))
        };
        
        // Create download link
        const dataStr = JSON.stringify(biomeData, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `${category.name}_biome_data.json`;
        link.click();
        
        URL.revokeObjectURL(url);
        
        // // // // // // // // console.log('[DataManager] Biome data exported');
        this.tileEditor.showToast('Biome-Daten wurden exportiert!', 'success');
    }
}

// Globale Verfügbarkeit
if (typeof window !== 'undefined') {
    window.DataManager = DataManager;
}
